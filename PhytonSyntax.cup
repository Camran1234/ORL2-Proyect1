import java_cup.runtime.XMLElement;
import java_cup.runtime.Symbol;

parser code {:
:}

terminal DECIMAL, NUMBER, PISTA, EXTIENDE, REPRODUCIR, ESPERAR, ORDENAR, ASCENDENTE, DESCENDENTE, PARES, IMPARES, 
PRIMOS, SUMARIZAR, LONGITUD, MENSAJE, PRINCIPAL, KEEP, VAR, ENTERO, DOBLE, BOOLEAN, CARACTER, CADENA, ARREGLO, SIMBOLO,
STRING, CHAR, IF, ELSE, SWITCH, CASE, EXIT, DEFAULT, FOR, WHILE, HACER, CONTINUE, DOR, RER, DO, RE, MI, FA, SOL, LA, SI,
EQUAL, EQUALIZATION, DIFFERENTIATION, GREATER_THAN, LESSER_THAN, NULL_, GREATER, LESSER, EQUAL_MORE, INCREASE, DECREASE,
ADD, MINUS, MULTIPLY, DIV, MODULE, POW, OPEN_BRACKET, CLOSE_BRACKET, OPEN_PARENTHESIS, CLOSE_PARENTHESIS, COLON, COMA,
NAND, AND, NOR, OR, XOR, NOT, TAB, SPACE, OPEN_CURLY, CLOSE_CURLY, RETORNA ; 

non terminal tab, function, type_function, type_function, multiple_v, function_variables, pista, d, d_, increm_variables,
increm, v, data_type, variables, variables_re, k, type, assign, equal, array, dimension, array_assign, assign_arr,
assign_arr_re, mult_values, mult_values_re, value, notas, func_especiales, reproducir_syntax, esperar_syntax,
sumarizar_syntax, longitud_syntax, mensaje_syntax, if, block_if, block_elseif, else_if, else, condition,
condition_re, comparation, switch, cases, for, for_condition, for_increm, for_instructions, while,
do_while, while_do;

/*precedences*/

precedence left ADD, MINUS;
precedence left DIV, MULT, MODULE;
precedence left POW;
precedence left NULL_, 
precedence left EQUALIZATION, DIFFERENTIATION, LESSER, LESSER_THAN, GREATER, GREATER_THAN;
precedence left NOT;
precedence left AND, NAND;
precedence left OR, NOR, XOR;
precedence left OPEN_PARENTHESIS, CLOSE_PARENTHESIS;
precedence left ELSE;

start with main_body;

main_body ::= tab principal main_body
        | tab pista main_body
        |tab function main_body
        |SPACE
        ;

principal ::= PRINCIPAL OPEN_PARENTHESIS CLOSE_PARENTHESIS SPACE instruction
        ;

/*Declaracion de variables, asignaciones, incrementos, for, while, do_while, if, switch, funciones especiales*/
instruction ::= tab increm_variables instruction
                |tab func_especiales instruction
                |tab v instruction
                |tab for instruction
                |tab while instruction
                |tab do_while instruction
                |tab if instruction
                |tab switch instruction
                |SPACE;

instruction_ciclo ::= instruction
                        |tab CONTINUE instruction_ciclo;

function_instruction ::= instruction
                        |tab RETORNA function_instruction;

/*NOTAS MUSICALES*/
notas ::= DO
        |RE
        |MI
        |FA
        |SOL
        |LA
        |SI
        |DOR
        |RER
        ;

/*FUNCIONES ESPECIALES*/

ordenar_options ::= ASCENDENTE
                |DESCENDENTE
                ;

reproducir_syntax ::= notas COMA value COMA value COMA value CLOSE_PARENTHESIS
                    ;

esperar_syntax ::= value COMA value CLOSE_PARENTHESIS
                    ;

sumarizar_syntax ::= value CLOSE_PARENTHESIS
                    ;

longitud_syntax ::= value CLOSE_PARENTHESIS
                    ;

mensaje_syntax ::= value CLOSE_PARENTHESIS
                    ;

ordenar_syntax ::= SIMBOLO COMA ordenar_options CLOSE_PARENTHESIS
                ;

func_especiales ::= REPRODUCIR OPEN_PARENTHESIS reproducir_syntax
                    |SUMARIZAR OPEN_PARENTHESIS sumarizar_syntax
                    |LONGITUD OPEN_PARENTHESIS longitud_syntax
                    |ESPERAR OPEN_PARENTHESIS esperar_syntax
                    |MENSAJE OPEN_PARENTHESIS mensaje_syntax
                    |ORDENAR OPEN_PARENTHESIS ordenar_syntax
                    ;


/*TAB*/
tab ::= TAB tab
        |/*empty*/
        ;
        
/*FUNCTION*/

function ::= k type_function OPEN_PARENTHESIS OPEN_BRACKET multiple_v CLOSE_PARENTHESIS SPACE function_instruction
            ;

type_function ::= k data_type
            ;

multiple_v ::= function_variables multiple_v_re
            |CLOSE_BRACKET
            ;

function_variables ::= data_type SIMBOLO
                    ;

/*PISTA*/
pista ::= PISTA SIMBOLO d instruccion
    |PISTA error d instruccion
    |PISTA SIMBOLO error instruccion
    ;

d ::= extiende SIMBOLO d#
    |/*empty*/
    ;

d_ ::= COMA SIMBOLO d_
    |error SIMBOLO d_
    |COMA error d_
    |/*empty*/
    ;

/*INCREMENTACION DE VARIABLES*/
increm_variables ::= SIMBOLO increm SPACE
                    ;

increm ::= INCREASE
            |DECREASE
            |error;

/*VARIABLES*/

v ::= type variables assign
    |variables assign
    ;

data_type ::= NUMBER array
        |DECIMAL array
        |BOOLEAN array
        |CADENA array
        |CARACTER array
        |error
        ;

variables ::= SIMBOLO variables_re
            |error variables_re
            ;

variables_re ::= COMA SIMBOLO variables_re
            |error SIMBOLO variables_re
            |COMA error variables_re
            |/*empty*/
            ;

k ::= KEEP
    |/*empty*/

type ::= k VAR data_type
        |k error data_type
        ;

/*ASIGNAR VALORES*/
assign ::= EQUAL value SPACE
    |equal array_assign SPACE
    ;

equal ::= EQUAL
        |EQUAL_MORE
        |error
        ;

array ::= ARRAY dimension
        |/*empty*/
        ;

dimension ::= OPEN_BRACKET value CLOSE_BRACKET dimension
        |/*empty*/
        ;

array_assign ::= OPEN_CURLY value CLOSE_CURLY
                ;

assign_arr ::= OPEN_CURLY mult_values CLOSE_CURLY assign_arr_re
                ;

assign_arr_re ::= COMA OPEN_CURLY mult_values CLOSE_CURLY assign_arr_re
                |/*empty*/
                ;

mult_values ::= value mult_values_re
            ;

mult_values_re ::= COMA value mult_values_re
                |/*empty*/
                ;

    /*VALORES*/
value ::= NUMBER
        |DECIMAL
        |STRING
        |CHAR
        |value ADD value
        |value MINUS value
        |value MULTIPLY value
        |value DIV value
        |value POW value
        |value MODULE value
        |OPEN_PARENTHESIS value CLOSE_PARENTHESIS
        |SIMBOLO
        |TRUE
        |func_especiales
        |FALSE
        |error
        ;

/*SI*/

if ::= block_if else_if else
        ;

block_if ::= IF OPEN_PARENTHESIS condition SPACE instruction
        ;

else_if ::= else_if block_elseif
        ;

block_elseif ::= ELSE IF OPEN_PARENTHESIS condition SPACE instruction
                |error IF OPEN_PARENTHESIS condition SPACE instruction
                |ELSE error OPEN_PARENTHESIS condition SPACE instruction
                |ELSE IF error condition SPACE instruction
                |ELSE IF OPEN_PARENTHESIS condition error instruction
                ;

else ::= ELSE SPACE instruction
        |error SPACE instruction
        |ELSE error instruction
        ;

/*CONDICION*/
/*this production end in close_parenthesis*/

condition ::= comparation condition_re
            ;

condition_re ::= AND comparation condition_re       
                |NAND comparation condition_re
                |OR comparation condition_re
                |NOR comparation condition_re
                |XOR comparation condition_re
                |CLOSE_PARENTHESIS
                |error comparation condition_re
                ;

comparation ::= comparation EQUALIZATION comparation
                |comparation DIFFERENTIATION comparation    
                |comparation GREATER comparation
                |comparation GREATER_THAN comparation
                |comparation LESSER comparation
                |comparation LESSER_THAN comparation
                |NULL_ comparation
                |NOT comparation
                |OPEN_PARENTHESIS comparation CLOSE_PARENTHESIS
                |value
                ;

/*SWITCH*/

switch ::= SWITCH OPEN_PARENTHESIS SIMBOLO CLOSE_PARENTHESIS SPACE cases
            | SWITCH error SIMBOLO CLOSE_PARENTHESIS SPACE cases
            | SWITCH OPEN_PARENTHESIS error CLOSE_PARENTHESIS SPACE cases
            | SWITCH OPEN_PARENTHESIS SIMBOLO error SPACE cases
            | SWITCH OPEN_PARENTHESIS SIMBOLO CLOSE_PARENTHESIS error cases
            ;

cases ::= tab CASO value SPACE instruction tab SALIR cases
        | tab error value SPACE instruction tab SALIR cases
        | tab CASO value error instruction tab SALIR cases
        | tab CASO value SPACE instruction tab error cases
        | SPACE
        ;

/*PARA*/

for ::= PARA OPEN_PARENTHESIS for_instructions SPACE instruction_ciclo
        ;

for_instructions ::= v COLON for_condition
                ;

for_condition ::= condition COLON for_increm
                ;

for_increm ::= increm_variables CLOSE_PARENTHESIS
                ;

/*WHILE*/

while ::= MIENTRAS OPEN_PARENTHESIS condition SPACE instruction_ciclo
        ;

/*DO WHILE*/

do_while ::= HACER SPACE instruction_ciclo while_do
        ;

while_do ::= tab MIENTRAS OPEN_PARENTHESIS condition SPACE
        ;

